(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{556:function(e,s,n){"use strict";n.r(s);var a=n(4),r=Object(a.a)({},(function(){var e=this,s=e.$createElement,n=e._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"背景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[e._v("#")]),e._v(" 背景")]),e._v(" "),n("ol",[n("li",[e._v("业务上常见的问题——并发冲突")])]),e._v(" "),n("p",[e._v("并发冲突问题是互联网项目常遇的坑点，不同用户在较短时间间隔内变更数据，或者某一个用户进行的重复提交操作都可能是导致并发冲突的原因，并发场景在开发和测试阶段难以排查全面，出现线上 bug 以后定位困难，因此做好并发控制是前后端开发过程中都需要重视的问题。")]),e._v(" "),n("p",[e._v("对于同一用户短时间内重复提交数据的问题，前端通常可以先做一层拦截。本文将讨论前端如何利用 axios 的拦截器过滤重复请求，解决并发冲突。")]),e._v(" "),n("ol",[n("li",[e._v("当前的处理方式——每次发请求添加 loading")])]),e._v(" "),n("p",[e._v("在尝试 axios 拦截器之前，先看看我们之前业务是怎么处理并发冲突问题的：每次用户操作页面上的控件（输入框、按钮等），向后端发送请求的时候，都给页面对应的控件添加 loading 效果，提示正在进行数据加载，同时也阻止 loading 效果结束前用户继续操作控件。")]),e._v(" "),n("p",[e._v("这是最直接有效的方式，如果你们前端团队成员足够细心耐心，拥有良好的编码习惯，这样就可以解决大部分用户不小心重复提交带来的并发问题了。")]),e._v(" "),n("h2",{attrs:{id:"更优的解决方案：-axios-拦截器统一处理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#更优的解决方案：-axios-拦截器统一处理"}},[e._v("#")]),e._v(" 更优的解决方案： axios 拦截器统一处理")]),e._v(" "),n("p",[e._v("项目中需要前端限制并发的场景这么多，我们当然要思考更优更省事的方案。既然是在每次发送请求的时候进行并发控制，那如果能重新封装下发请求的公共函数，统一处理重复请求实现自动拦截，就可以大大简化我们的业务代码。")]),e._v(" "),n("p",[e._v("项目使用的 "),n("a",{attrs:{href:"https://www.npmjs.com/package/axios",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("axios")]),n("OutboundLink")],1),e._v(" 库来发送 "),n("code",[e._v("http")]),e._v(" 请求，"),n("code",[e._v("axios")]),e._v(" 官方为我们提供了丰富的 API，我们来看看拦截请求需要用到的两个核心 API:")]),e._v(" "),n("ol",[n("li",[n("p",[n("code",[e._v("interceptors")]),e._v(":")]),e._v(" "),n("p",[e._v("拦截器包括请求拦截器和响应拦截器，可以在请求发送前或者响应后进行拦截处理，用法如下：")])])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 添加请求拦截器\naxios.interceptors.request.use(function (config) {\n  // 在发送请求之前做些什么\n  return config;\n}, function (error) {\n  // 对请求错误做些什么\n  return Promise.reject(error);\n});\n\n// 添加响应拦截器\naxios.interceptors.response.use(function (response) {\n    // 对响应数据做点什么\n    return response;\n  }, function (error) {\n    // 对响应错误做点什么\n    return Promise.reject(error);\n  });\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br"),n("span",{staticClass:"line-number"},[e._v("15")]),n("br"),n("span",{staticClass:"line-number"},[e._v("16")]),n("br"),n("span",{staticClass:"line-number"},[e._v("17")]),n("br")])]),n("ol",{attrs:{start:"2"}},[n("li",[n("p",[n("code",[e._v("cancel token")]),e._v(":")]),e._v(" "),n("p",[e._v("调用 "),n("code",[e._v("cancel token API")]),e._v(" 可以取消请求。官网提供了两种方式来构建 "),n("code",[e._v("cancel token")]),e._v("，我们采用这种方式：通过传递一个 "),n("code",[e._v("executor")]),e._v(" 函数到 "),n("code",[e._v("CancelToken")]),e._v(" 的构造函数来创建 "),n("code",[e._v("cancel token")]),e._v("，方便在上面的请求拦截器中检测到重复请求可以立即执行:")])])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const CancelToken = axios.CancelToken;\nlet cancel;\n\naxios.get('/user/12345', {\n  cancelToken: new CancelToken(function executor(c) {\n    // executor 函数接收一个 cancel 函数作为参数\n    cancel = c;\n  })\n});\n\n// cancel the request\ncancel();\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br")])]),n("p",[n("strong",[e._v("本文提供的思路就是利用 "),n("code",[e._v("axios interceptors API")]),e._v(" 拦截请求，检测是否有多个相同的请求同时处于 pending 状态，如果有就调用 "),n("code",[e._v("cancel token API")]),e._v(" 取消重复的请求。")])]),e._v(" "),n("p",[e._v("假如用户重复点击按钮，先后提交了 A 和 B 这两个完全相同（考虑请求路径、方法、参数）的请求，我们可以从以下几种拦截方案中选择其一：")]),e._v(" "),n("ul",[n("li",[e._v("取消 A 请求，只发出 B 请求")]),e._v(" "),n("li",[e._v("取消 B 请求，只发出 A 请求")]),e._v(" "),n("li",[e._v("取消 B 请求，只发出 A 请求，把收到的 A 请求的返回结果也作为 B 请求的返回结果")])]),e._v(" "),n("p",[e._v("第三种方案需要做监听处理增加了复杂性，结合我们实际的业务需求，最后采用了第二种方案来实现，即：")]),e._v(" "),n("p",[n("strong",[e._v("只发第一个请求。在 A 请求还处于 pending 状态时，后发的所有与 A 重复的请求都取消，实际只发出 A 请求，直到 A 请求结束（成功/失败）才停止对这个请求的拦截。")])]),e._v(" "),n("h2",{attrs:{id:"具体实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#具体实现"}},[e._v("#")]),e._v(" 具体实现")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("存储所有 pending 状态的请求")]),e._v(" "),n("p",[e._v("首先我们要将项目中所有的 pending 状态的请求存储在一个变量中，叫它 "),n("code",[e._v("pendingRequests")]),e._v("，")]),e._v(" "),n("p",[e._v("可以通过把 "),n("code",[e._v("axios")]),e._v(" 封装为一个单例模式的类，或者定义全局变量，来保证 "),n("code",[e._v("pendingRequests")]),e._v(" 变量在每次发送请求前都可以访问，并检查是否为重复的请求。")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let pendingRequests = new Map()\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("p",[e._v("把每个请求的方法、url 和参数组合成一个字符串，作为标识该请求的唯一 key，同时也是 "),n("code",[e._v("pendingRequests")]),e._v(" 对象的 key:")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const requestKey = `${config.url}/${JSON.stringify(config.params)}/${JSON.stringify(config.data)}&request_type=${config.method}`;\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("p",[e._v("帮助理解的小 tips:")]),e._v(" "),n("ul",[n("li",[e._v("定义 "),n("code",[e._v("pendingRequests")]),e._v(" 为 map 对象的目的是为了方便我们查询它是否包含某个 key，以及添加和删除 key。添加 key 时，对应的 value 可以设置用户自定义的一些功能参数，后面扩展功能的时候会用到。")]),e._v(" "),n("li",[n("code",[e._v("config")]),e._v(" 是 "),n("code",[e._v("axios")]),e._v(" 拦截器中的参数，包含当前请求的信息")])])]),e._v(" "),n("li",[n("p",[e._v("在请求发出前检查当前请求是否重复")]),e._v(" "),n("p",[e._v("在请求拦截器中，生成上面的 "),n("code",[e._v("requestKey")]),e._v("，检查 "),n("code",[e._v("pendingRequests")]),e._v(" 对象中是否包含当前请求的 "),n("code",[e._v("requestKey")])]),e._v(" "),n("ul",[n("li",[e._v("有：说明是重复的请求，cancel 掉当前请求")]),e._v(" "),n("li",[e._v("没有：把 "),n("code",[e._v("requestKey")]),e._v(" 添加到 "),n("code",[e._v("pendingRequests")]),e._v(" 对象中")])]),e._v(" "),n("p",[e._v("因为后面的响应拦截器中还要用到当前请求的 "),n("code",[e._v("requestKey")]),e._v("，为了避免踩坑，最好不要再次生成，在这一步就把 "),n("code",[e._v("requestKey")]),e._v(" 存回 "),n("code",[e._v("axios")]),e._v(" 拦截器的 "),n("code",[e._v("config")]),e._v(" 参数中，后面可以直接在响应拦截器中通过 "),n("code",[e._v("response.config.requestKey")]),e._v(" 取到。")]),e._v(" "),n("p",[e._v("代码示例：")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 请求拦截器\naxios.interceptors.request.use(\n  (config) => {\n    if (pendingRequests.has(requestKey)) {\n      config.cancelToken = new axios.CancelToken((cancel) => {\n        // cancel 函数的参数会作为 promise 的 error 被捕获\n        cancel(`重复的请求被主动拦截: ${requestKey}`);\n      });\n    } else {\n      pendingRequests.set(requestKey, config);\n      config.requestKey = requestKey;\n    }\n    return config;\n  },\n  (error) => {\n    // 这里出现错误可能是网络波动造成的，清空 pendingRequests 对象\n    pendingRequests.clear();\n    return Promise.reject(error);\n  }\n);\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br"),n("span",{staticClass:"line-number"},[e._v("15")]),n("br"),n("span",{staticClass:"line-number"},[e._v("16")]),n("br"),n("span",{staticClass:"line-number"},[e._v("17")]),n("br"),n("span",{staticClass:"line-number"},[e._v("18")]),n("br"),n("span",{staticClass:"line-number"},[e._v("19")]),n("br"),n("span",{staticClass:"line-number"},[e._v("20")]),n("br")])])]),e._v(" "),n("li",[n("p",[e._v("在请求返回后维护 "),n("code",[e._v("pendingRequests")]),e._v(" 对象")]),e._v(" "),n("p",[e._v("如果请求顺利走到了响应拦截器这一步，说明这个请求已经结束了 pending 状态，那我们要把它从 "),n("code",[e._v("pendingRequests")]),e._v(" 中除名：")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("axios.interceptors.response.use((response) => {\n  const requestKey = response.config.requestKey;\n  pendingRequests.delete(requestKey);\n  return Promise.resolve(response);\n}, (error) => {\n  if (axios.isCancel(error)) {\n    console.warn(error);\n    return Promise.reject(error);\n  }\n  pendingRequests.clear();\n  return Promise.reject(error);\n})\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br")])])]),e._v(" "),n("li",[n("p",[e._v("需要清空 "),n("code",[e._v("pendingRequests")]),e._v(" 对象的场景")]),e._v(" "),n("p",[e._v("遇到网络波动或者超时等情况造成请求错误时，需要清空原来存储的所有 pending 状态的请求记录，在上面演示的代码已经作了注释说明。")]),e._v(" "),n("p",[e._v("此外，页面切换时也需要清空之前缓存的 "),n("code",[e._v("pendingRequests")]),e._v(" 对象，可以利用 "),n("code",[e._v("Vue Router")]),e._v(" 的 "),n("code",[e._v("beforeEach")]),e._v(" 钩子：")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("router.beforeEach((to, from, next) => {\n  request.clearRequestList();\n  next();\n});\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br")])])])]),e._v(" "),n("h2",{attrs:{id:"功能扩展"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#功能扩展"}},[e._v("#")]),e._v(" 功能扩展")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("统一处理接口报错提示")]),e._v(" "),n("p",[e._v("与后端约定好接口返回数据的格式，对接口报错的情况，可以统一在响应拦截器中添加 toast 给用户提示，")]),e._v(" "),n("p",[e._v("对于特殊的不需要报错的接口，可以设置一个参数存入 "),n("code",[e._v("axios")]),e._v(" 拦截器的 "),n("code",[e._v("config")]),e._v(" 参数中，过滤掉报错提示")])])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 接口返回 retcode 不为 0 时需要报错，请求设置了 noError 为 true 则这个接口不报错 \nif (\n  response.data.retcode &&\n  !response.config.noError\n) {\n  if (response.data.message) {\n    Vue.prototype.$message({\n      showClose: true,\n      message: response.data.message,\n      type: 'error',\n    });\n  }\n  return Promise.reject(response.data);\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br")])]),n("ol",{attrs:{start:"2"}},[n("li",[n("p",[e._v("发送请求时给控件添加 loading 效果")]),e._v(" "),n("p",[e._v("上面利用 "),n("code",[e._v("axios interceptors")]),e._v(" 过滤重复请求时，可以在控制台抛出信息给开发者提示，在这个基础上如果能给页面上操作的控件添加 loading 效果就会对用户更友好。")]),e._v(" "),n("p",[e._v("常见的 ui 组件库都有提供 loading 服务，可以指定页面上需要添加 loading 效果的控件。下面是以 "),n("code",[e._v("element UI")]),e._v(" 为例的示例代码：")])])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 给 loadingTarget 对应的控件添加 loading 效果，储存 loadingService 实例\naddLoading(config) {\n  if (!document.querySelector(config.loadingTarget)) return;\n  config.loadingService = Loading.service({\n    target: config.loadingTarget,\n  });\n}\n\n// 调用 loadingService 实例的 close 方法关闭对应元素的 loading 效果\ncloseLoading(config) {\n  config.loadingService && config.loadingService.close();\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br")])]),n("p",[e._v("与上面过滤报错方式类似，发请求的时候将元素的 class name 或 id 存入 "),n("code",[e._v("axios")]),e._v(" 拦截器的 "),n("code",[e._v("config")]),e._v(" 参数中，")]),e._v(" "),n("p",[e._v("在请求拦截器中调用 "),n("code",[e._v("addLoading")]),e._v(" 方法, 响应拦截器中调用 "),n("code",[e._v("closeLoading")]),e._v(" 方法，就可以实现在请求 pending 过程中指定控件（如 button） loading，请求结束后控件自动取消 loading 效果。")]),e._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[n("p",[e._v("支持多个拦截器组合使用")]),e._v(" "),n("p",[e._v("简单看下 "),n("code",[e._v("axios interceptors")]),e._v(" 部分实现源码可以理解，它支持定义多个 "),n("code",[e._v("interceptors")]),e._v("，所以只要我们定义的 "),n("code",[e._v("interceptors")]),e._v(" 符合   "),n("code",[e._v("Promise.then")]),e._v(" 链式调用的规范，还可以添加更多功能")])])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n  chain.unshift(interceptor.fulfilled, interceptor.rejected);\n});\n\nthis.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n  chain.push(interceptor.fulfilled, interceptor.rejected);\n});\n\nwhile (chain.length) {\n  promise = promise.then(chain.shift(), chain.shift());\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br")])]),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("p",[e._v("并发问题很常见，处理起来又相对繁琐，前端解决并发冲突时，可以利用 axios 拦截器统一处理重复请求，简化业务代码。同时 axios 拦截器支持更多应用，本文提供了部分常用扩展功能的实现，感兴趣的同学可以继续挖掘补充拦截器的其他用法，希望对你有帮助。")])])}),[],!1,null,null,null);s.default=r.exports}}]);