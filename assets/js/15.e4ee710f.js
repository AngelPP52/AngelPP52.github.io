(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{446:function(t,a,r){t.exports=r.p+"assets/img/rabbitmq-practice.55218cb4.png"},447:function(t,a,r){t.exports=r.p+"assets/img/RabbitMQ-ha.1a2ec8b9.png"},448:function(t,a,r){t.exports=r.p+"assets/img/MQ-Server-ha.20811389.png"},486:function(t,a,r){"use strict";r.r(a);var v=r(44),e=Object(v.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"一、rabbitmq简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、rabbitmq简介"}},[t._v("#")]),t._v(" 一、RabbitMQ简介")]),t._v(" "),v("p",[v("strong",[t._v("RabbitMQ 是实现了 AMQP 协议的开源消息代理软件，起源于金融系统")])]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("1、RabbitMQ作用")])]),t._v(" "),v("ul",[v("li",[t._v("异步处理")]),t._v(" "),v("li",[t._v("削峰填谷")]),t._v(" "),v("li",[t._v("系统解耦")]),t._v(" "),v("li",[t._v("消息广播")])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("2、AMQP协议")])])])]),t._v(" "),v("blockquote",[v("p",[t._v("AMQP 0-9-1的工作过程如下图：消息（message）被发布者（publisher）发送给交换机（exchange），交换机常常被比喻成邮局或者邮箱。\n然后交换机将收到的消息根据路由规则分发给绑定的队列（queue）。最后AMQP代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。\n"),v("img",{attrs:{src:"https://www.rabbitmq.com/img/tutorials/intro/hello-world-example-routing.png",alt:"AMQP协议简单模型"}}),t._v("\n发布者（publisher）发布消息时可以给消息指定各种消息属性（message meta-data）。有些属性有可能会被消息代理（brokers）使用，\n然而其他的属性则是完全不透明的，它们只能被接收消息的应用所使用。\n从安全角度考虑，网络是不可靠的，接收消息的应用也有可能在处理消息的时候失败。基于此原因，AMQP模块包含了一个消息确认（message acknowledgements）\n的概念：当一个消息从队列中投递给消费者后（consumer），消费者会通知一下消息代理（broker），这个可以是自动的也可以由处理消息的应用的开发者执行。当“消息确认”被启用的时候，消息代理不会完全将消息从队列中删除，直到它收到来自消费者的确认回执（acknowledgement）。\n在某些情况下，例如当一个消息无法被成功路由时，消息或许会被返回给发布者并被丢弃。或者，如果消息代理执行了延期操作，消息会被放入一个所谓的死信队列中。\n此时，消息发布者可以选择某些参数来处理这些特殊情况。\n队列，交换机和绑定统称为AMQP实体（AMQP entities）")])]),t._v(" "),v("h2",{attrs:{id:"二、rabbitmq使用遇到的问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、rabbitmq使用遇到的问题"}},[t._v("#")]),t._v(" 二、RabbitMQ使用遇到的问题")]),t._v(" "),v("h3",{attrs:{id:"集群不可用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#集群不可用"}},[t._v("#")]),t._v(" 集群不可用")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("1、脑裂")]),t._v(" "),v("ul",[v("li",[t._v("原因\n"),v("strong",[t._v("网络分区或者系统挂起")])])]),t._v(" "),v("blockquote",[v("p",[t._v("当集群中的不同的节点发生交互失败中断(communication interrupted)等，但是又没有节点挂掉这种情况下，\n才是发生了分区。除了网络失败(network failures)原因，操作系统的挂起或者恢复也会导致集群内节点的网络分区。因为发生挂起的节点不会认为自身已经失败或者停止工作，但是集群内的其他节点会这么认为。")])]),t._v(" "),v("ul",[v("li",[t._v("选择策略\n"),v("ul",[v("li",[v("strong",[t._v("ignore")]),t._v(": 网络分区后需要手动处理，消息可能丢失，适用于网络很可靠的情况，如所有的节点都在一个机架上，连接在同一个交换机上，这个交换机也连接在WAN上，你不需要冒险而关闭部分节点。")]),t._v(" "),v("li",[v("strong",[t._v("pause_minority")]),t._v(": 分区少数节点会暂定服务，知道网络联通恢复，适用于网络相对没有那么的可靠。比如你在EC2上建立了三个节点的集群，假设其中一个节点宕了，在这种策略下，剩余的两个节点还可以继续工作，失败的节点可以在恢复之后重新加入集群")]),t._v(" "),v("li",[v("strong",[t._v("autoheal")]),t._v(": 少数节点将会自动重启，你的网络非常不可靠，你更关心服务的连续性而不是数据的完整性。适合有两个节点的集群。")])])])]),t._v(" "),v("blockquote",[v("p",[t._v("一般选择pause_minority策略，保证服务可用性；")])])]),t._v(" "),v("li",[v("strong",[t._v("2、集群挂了")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("原因\n"),v("strong",[t._v("断电了或者物理原因等")])])]),t._v(" "),v("li",[v("p",[t._v("选择策略")]),t._v(" "),v("ul",[v("li",[t._v("双活或多活部署集群，如果只是少部分节点挂了，整个集群还可用，但是如果整个集群挂了那就只能将流量切换到多活机房，并且要保证流量不会打垮切换到的集群；")])])])])])]),t._v(" "),v("h3",{attrs:{id:"集群负载过高"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#集群负载过高"}},[t._v("#")]),t._v(" 集群负载过高")]),t._v(" "),v("ul",[v("li",[t._v("内存消耗过多\n"),v("ul",[v("li",[t._v("普通队列")])]),t._v(" "),v("blockquote",[v("p",[t._v("默认情况下，当生产者将消息发送到RabbitMQ的时候，队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当RabbitMQ需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。")])]),t._v(" "),v("ul",[v("li",[t._v("惰性(lazy)队列")])]),t._v(" "),v("blockquote",[v("p",[t._v("惰性队列会将接收到的消息直接存入文件系统中，而不管是持久化的或者是非持久化的，这样可以减少了内存的消耗，但是会增加I/O的使用，如果消息是持久化的，那么这样的I/O操作不可避免，惰性队列和持久化消息可谓是“最佳拍档”。注意如果惰性队列中存储的是非持久化的消息，内存的使用率会一直很稳定，但是重启之后消息一样会丢失")])]),t._v(" "),v("ul",[v("li",[t._v("惰性队列好处")])]),t._v(" "),v("blockquote",[v("p",[t._v("据官网测试数据显示，对于普通队列，如果要发送1千万条消息，需要耗费801秒，平均发送速度约为13000条/秒。如果使用惰性队列，那么发送同样多的消息时，耗时是421秒，平均发送速度约为24000条/秒。\n出现性能偏差的原因是普通队列会由于内存不足而不得不将消息换页至磁盘。如果有消费者消费时，惰性队列会耗费将近40MB的空间来发送消息，对于一个消费者的情况，平均的消费速度约为14000条/秒。\n同时，内存消耗大大减少。官网测试显示一百万条消息，普通队列占用257MB内存，惰性队列只需159 KB内存；")])])]),t._v(" "),v("li",[t._v("Tps过高、连接数过多、队列数过多\n"),v("ul",[v("li",[t._v("解决方案\n"),v("strong",[t._v("如何解决呢？")])])])])]),t._v(" "),v("h3",{attrs:{id:"消息丢失"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息丢失"}},[t._v("#")]),t._v(" 消息丢失")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("1、反查表+重试任务+消息队列")]),t._v(" "),v("img",{attrs:{src:r(446),alt:"反查表+重试任务+消息队列"}})])]),t._v(" "),v("h3",{attrs:{id:"rabbitmq-or-kafka"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-or-kafka"}},[t._v("#")]),t._v(" RabbitMQ Or Kafka")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("1、实现区别")]),t._v(" "),v("ul",[v("li",[t._v("RabbitMQ存储基于队列与交换机，Kafka的存储层使用分区事务日志")])])]),t._v(" "),v("li",[v("p",[t._v("2、RabbitMQ可以设置TTL、发送延迟消息")])]),t._v(" "),v("li",[v("p",[t._v("3、Kafka可以在一定时间内保存消息")])]),t._v(" "),v("li",[v("p",[t._v("4、容错机制")]),t._v(" "),v("ul",[v("li",[t._v("RabbitMQ提供死信交换器（DLX）来处理消息处理故障，不会阻塞后续消息处理")]),t._v(" "),v("li",[t._v("Kafka消息顺序不能改变，需要应用层做处理重试消息")])])]),t._v(" "),v("li",[v("p",[t._v("5、伸缩能力")]),t._v(" "),v("ul",[v("li",[t._v("Kafka横向扩展能力优于RabbitMQ，大规模部署通常每秒可以处理数十万条消息，甚至每秒百万级别的消息")]),t._v(" "),v("li",[t._v("RabbitMQ不将消息负载到不同集群处理能力每秒几万左右，但是通过消息负载到不同队列，三十个节点可以达到每秒百万级别："),v("a",{attrs:{href:"https://tanzu.vmware.com/content/blog/rabbitmq-hits-one-million-messages-per-second-on-google-compute-engine",target:"_blank",rel:"noopener noreferrer"}},[t._v("基准测试链接"),v("OutboundLink")],1)])])]),t._v(" "),v("li",[v("p",[t._v("根据业务属性选择使用哪种中间件，更重要的是开发运维熟悉哪种中间件，出了问题是否能得到及时响应解决")])])]),t._v(" "),v("h3",{attrs:{id:"多集群如何管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多集群如何管理"}},[t._v("#")]),t._v(" 多集群如何管理")]),t._v(" "),v("ul",[v("li",[t._v("提供统一的集群管理平台")])]),t._v(" "),v("h2",{attrs:{id:"三、rabbitmq集群高可用实践"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、rabbitmq集群高可用实践"}},[t._v("#")]),t._v(" 三、RabbitMQ集群高可用实践")]),t._v(" "),v("h3",{attrs:{id:"背景："}},[v("a",{staticClass:"header-anchor",attrs:{href:"#背景："}},[t._v("#")]),t._v(" 背景：")]),t._v(" "),v("ul",[v("li",[t._v("1、所有业务共用一个集群，随意接入集群，创建队列；")]),t._v(" "),v("li",[t._v("2、集群负载严重，很难维护生产消费接入方的关系信息，集群经常不可用；")]),t._v(" "),v("li",[t._v("3、达到单集群性能瓶颈，集群直接不可用；")])]),t._v(" "),v("h3",{attrs:{id:"rabbitmq高可用架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq高可用架构"}},[t._v("#")]),t._v(" RabbitMQ高可用架构")]),t._v(" "),v("p",[v("img",{attrs:{src:r(447),alt:"RabbitMQ高可用架构"}})]),t._v(" "),v("ul",[v("li",[t._v("1、MQ-Portal--用于支持应用使用申请")]),t._v(" "),v("li",[t._v("2、客户端SDK能力")])]),t._v(" "),v("blockquote",[v("p",[t._v("a、应用使用鉴权\nb、集群寻址\nc、客户端限流\nd、生产消费重置\ne、阻塞转移\nf、多集群调度")])]),t._v(" "),v("ul",[v("li",[t._v("3、MQ-NameServer\nMQ-NameServer为无状态服务，通过集群部署即可保障自身高可用，主要用于解决以下问题：")])]),t._v(" "),v("blockquote",[v("p",[t._v("a、MQ-SDK启动鉴权以及应用使用集群定位。\nb、处理MQ-SDK的定时指标上报（消息发送数量、消息消费数量），并且返回当前可用集群地址，确保SDK在集群异常时按照正确地址进行重连。\nc、控制MQ-SDK进行生产消费重置。")])]),t._v(" "),v("h3",{attrs:{id:"mq-server高可用部署实践"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mq-server高可用部署实践"}},[t._v("#")]),t._v(" MQ-Server高可用部署实践")]),t._v(" "),v("p",[v("img",{attrs:{src:r(448),alt:"MQ-Server高可用部署实践"}}),t._v("\nRabbitMQ 集群均采用同城双活部署架构，通过Federation插件将双集群组成联盟集群，依靠MQ-SDK和MQ-NameServer提供的集群寻址、故障快速切换等能力保障集群的可用性。")]),t._v(" "),v("ul",[v("li",[t._v("1、集群基本配置\n"),v("ul",[v("li",[t._v("一般使用3到7个奇数节点部署RabbitMQ集群；")]),t._v(" "),v("li",[t._v("集群队列均为镜像队列，确保消息存在备份，避免节点异常导致消息丢失；")]),t._v(" "),v("li",[t._v("exchange、queue、消息均设置为持久化，避免节点异常重启消息丢失；")]),t._v(" "),v("li",[t._v("队列均设置为lazy queues，减少节点内存使用的波动，提高消息发送速率；")])])]),t._v(" "),v("li",[t._v("2、多集群配置\n"),v("blockquote",[v("p",[t._v("A机房与B机房的RabbitMQ集群通过Federation插件将双集群组成联盟集群，互为热备；\nA机房与B机房内部有多个RabbitMQ集群，对用户组成一个透明的逻辑RabbitMQ集群，对用户透明；\n将一个逻辑队列拆分为多个物理队列分配到各自机房逻辑RabbitMQ集群，突破单个集群吞吐量，拥有逻辑RabbitMQ集群的吞吐量，通过消息负载到不同队列，三十个节点可以达到每秒百万级别；")])])]),t._v(" "),v("li",[t._v("3、案例\n"),v("ul",[v("li",[t._v("机房断电")])]),t._v(" "),v("blockquote",[v("p",[t._v("通过sdk探活，切换到命名服务下发的热备集群地址，自动重置连接到新的集群，保证了服务的高可用；")])]),t._v(" "),v("ul",[v("li",[t._v("提现请求激增")])]),t._v(" "),v("blockquote",[v("p",[t._v("检测到队列长度告警增加逻辑集群中集群数量，下发地址到sdk，部分生产者消费者连接到新的集群，逻辑队列消息分发到新的集群，单集群队列长度减半；")])])])]),t._v(" "),v("h3",{attrs:{id:"目前遇到的问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#目前遇到的问题"}},[t._v("#")]),t._v(" 目前遇到的问题")]),t._v(" "),v("ul",[v("li",[t._v("1、创建的队列不是惰性(lazy)队列，当消息堆积时对内存消耗很大，延时激增，且平均消息发送速度减小；")]),t._v(" "),v("li",[t._v("2、连接数过多，发送到同一个集群相同队列的消息按市场或者hash分发到不同集群；")]),t._v(" "),v("li",[t._v("3、cpu被其他进程占用，采用绑定cpu方式防止cpu资源被其他进程耗尽；")])]),t._v(" "),v("p",[t._v("参考链接：\n"),v("a",{attrs:{href:"https://mp.weixin.qq.com/s/7s9-RsLWgiVvw28U51J0bA",target:"_blank",rel:"noopener noreferrer"}},[t._v("vivo-RabbitMQ高可用架构实践"),v("OutboundLink")],1),t._v(" "),v("a",{attrs:{href:"https://www.cnblogs.com/liyongsan/p/9640361.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("RabbitMQ脑裂问题解决方案调查"),v("OutboundLink")],1),t._v(" "),v("a",{attrs:{href:"https://www.rabbitmq.com/lazy-queues.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("RabbitMq官网"),v("OutboundLink")],1),t._v(" "),v("a",{attrs:{href:"https://honeypps.com/mq/rabbitmq-analysis-of-lazy-queue/",target:"_blank",rel:"noopener noreferrer"}},[t._v("惰性队列介绍"),v("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=e.exports}}]);