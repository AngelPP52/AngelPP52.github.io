<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浅谈Top K问题 | Shopee 供应链技术博客</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="Share Our Knowledge.">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <link rel="preload" href="/assets/css/0.styles.65389751.css" as="style"><link rel="preload" href="/assets/js/app.89d7a7af.js" as="script"><link rel="preload" href="/assets/js/3.39c0dfdf.js" as="script"><link rel="preload" href="/assets/js/1.fc4f2573.js" as="script"><link rel="preload" href="/assets/js/11.42709e7b.js" as="script"><link rel="prefetch" href="/assets/js/10.8f886ff6.js"><link rel="prefetch" href="/assets/js/12.51c95e33.js"><link rel="prefetch" href="/assets/js/13.a7db2e06.js"><link rel="prefetch" href="/assets/js/14.b9fd5312.js"><link rel="prefetch" href="/assets/js/15.02f2a353.js"><link rel="prefetch" href="/assets/js/16.f2b3bba4.js"><link rel="prefetch" href="/assets/js/17.fa6f4a21.js"><link rel="prefetch" href="/assets/js/18.cc202cb1.js"><link rel="prefetch" href="/assets/js/19.b74d740a.js"><link rel="prefetch" href="/assets/js/20.4f1350b1.js"><link rel="prefetch" href="/assets/js/21.7011a4c9.js"><link rel="prefetch" href="/assets/js/22.71907870.js"><link rel="prefetch" href="/assets/js/23.7ea72b1e.js"><link rel="prefetch" href="/assets/js/24.156af4ed.js"><link rel="prefetch" href="/assets/js/25.705d13d1.js"><link rel="prefetch" href="/assets/js/26.90da6739.js"><link rel="prefetch" href="/assets/js/27.a1d9dc04.js"><link rel="prefetch" href="/assets/js/28.7b9ee58e.js"><link rel="prefetch" href="/assets/js/29.c14786fa.js"><link rel="prefetch" href="/assets/js/30.cc235e35.js"><link rel="prefetch" href="/assets/js/4.d90b791b.js"><link rel="prefetch" href="/assets/js/5.16307cd7.js"><link rel="prefetch" href="/assets/js/6.3a371881.js"><link rel="prefetch" href="/assets/js/7.40292f84.js"><link rel="prefetch" href="/assets/js/8.651698aa.js"><link rel="prefetch" href="/assets/js/9.fdd84905.js">
    <link rel="stylesheet" href="/assets/css/0.styles.65389751.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-19557b78><div data-v-19557b78><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-19557b78 data-v-19557b78><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-19557b78 data-v-19557b78><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>Shopee 供应链技术博客</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>Shopee Supply Chain</span>
            
          <!---->
          2021
        </a></span></div></div> <div class="hide" data-v-19557b78><header class="navbar" data-v-19557b78><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/shopee.png" alt="Shopee 供应链技术博客" class="logo"> <span class="site-name">Shopee 供应链技术博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/database/" class="nav-link"><i class="iconfont undefined"></i>
  database
</a></li><li class="dropdown-item"><!----> <a href="/categories/CompilerTheory,Golang/" class="nav-link"><i class="iconfont undefined"></i>
  CompilerTheory,Golang
</a></li><li class="dropdown-item"><!----> <a href="/categories/MVCC/" class="nav-link"><i class="iconfont undefined"></i>
  MVCC
</a></li><li class="dropdown-item"><!----> <a href="/categories/golang/" class="nav-link"><i class="iconfont undefined"></i>
  golang
</a></li><li class="dropdown-item"><!----> <a href="/categories/Spark/" class="nav-link"><i class="iconfont undefined"></i>
  Spark
</a></li><li class="dropdown-item"><!----> <a href="/categories/CSS/" class="nav-link"><i class="iconfont undefined"></i>
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/categories/efficiency/" class="nav-link"><i class="iconfont undefined"></i>
  efficiency
</a></li><li class="dropdown-item"><!----> <a href="/categories/Performance/" class="nav-link"><i class="iconfont undefined"></i>
  Performance
</a></li><li class="dropdown-item"><!----> <a href="/categories/http/" class="nav-link"><i class="iconfont undefined"></i>
  http
</a></li><li class="dropdown-item"><!----> <a href="/categories/react/" class="nav-link"><i class="iconfont undefined"></i>
  react
</a></li><li class="dropdown-item"><!----> <a href="/categories/Middleware/" class="nav-link"><i class="iconfont undefined"></i>
  Middleware
</a></li><li class="dropdown-item"><!----> <a href="/categories/Security/" class="nav-link"><i class="iconfont undefined"></i>
  Security
</a></li><li class="dropdown-item"><!----> <a href="/categories/git/" class="nav-link"><i class="iconfont undefined"></i>
  git
</a></li><li class="dropdown-item"><!----> <a href="/categories/Algorithm/" class="nav-link"><i class="iconfont undefined"></i>
  Algorithm
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-19557b78></div> <aside class="sidebar" data-v-19557b78><div class="personal-info-wrapper" data-v-b038cec6><img src="/shopee.png" alt="author-avatar" class="personal-img" data-v-b038cec6> <h3 class="name" data-v-b038cec6>
    Shopee Supply Chain
  </h3> <div class="num" data-v-b038cec6><div data-v-b038cec6><h3 data-v-b038cec6>17</h3> <h6 data-v-b038cec6>Article</h6></div> <div data-v-b038cec6><h3 data-v-b038cec6>17</h3> <h6 data-v-b038cec6>Tag</h6></div></div> <hr data-v-b038cec6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/database/" class="nav-link"><i class="iconfont undefined"></i>
  database
</a></li><li class="dropdown-item"><!----> <a href="/categories/CompilerTheory,Golang/" class="nav-link"><i class="iconfont undefined"></i>
  CompilerTheory,Golang
</a></li><li class="dropdown-item"><!----> <a href="/categories/MVCC/" class="nav-link"><i class="iconfont undefined"></i>
  MVCC
</a></li><li class="dropdown-item"><!----> <a href="/categories/golang/" class="nav-link"><i class="iconfont undefined"></i>
  golang
</a></li><li class="dropdown-item"><!----> <a href="/categories/Spark/" class="nav-link"><i class="iconfont undefined"></i>
  Spark
</a></li><li class="dropdown-item"><!----> <a href="/categories/CSS/" class="nav-link"><i class="iconfont undefined"></i>
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/categories/efficiency/" class="nav-link"><i class="iconfont undefined"></i>
  efficiency
</a></li><li class="dropdown-item"><!----> <a href="/categories/Performance/" class="nav-link"><i class="iconfont undefined"></i>
  Performance
</a></li><li class="dropdown-item"><!----> <a href="/categories/http/" class="nav-link"><i class="iconfont undefined"></i>
  http
</a></li><li class="dropdown-item"><!----> <a href="/categories/react/" class="nav-link"><i class="iconfont undefined"></i>
  react
</a></li><li class="dropdown-item"><!----> <a href="/categories/Middleware/" class="nav-link"><i class="iconfont undefined"></i>
  Middleware
</a></li><li class="dropdown-item"><!----> <a href="/categories/Security/" class="nav-link"><i class="iconfont undefined"></i>
  Security
</a></li><li class="dropdown-item"><!----> <a href="/categories/git/" class="nav-link"><i class="iconfont undefined"></i>
  git
</a></li><li class="dropdown-item"><!----> <a href="/categories/Algorithm/" class="nav-link"><i class="iconfont undefined"></i>
  Algorithm
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>浅谈Top K问题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/views/other/topk/topk.html#_1-背景" class="sidebar-link">1. 背景</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/views/other/topk/topk.html#_2-阐述top-k问题" class="sidebar-link">2. 阐述Top K问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/views/other/topk/topk.html#_2-1-top-k-on-single-node" class="sidebar-link">2.1 Top K on Single Node</a></li><li class="sidebar-sub-header"><a href="/views/other/topk/topk.html#_2-2-top-k-on-multiple-node" class="sidebar-link">2.2 Top K on Multiple Node</a></li><li class="sidebar-sub-header"><a href="/views/other/topk/topk.html#_2-3-realtime-top-k-with-low-qps" class="sidebar-link">2.3 Realtime Top K with low QPS</a></li><li class="sidebar-sub-header"><a href="/views/other/topk/topk.html#_2-4-realtime-top-k-with-high-qps" class="sidebar-link">2.4 Realtime Top K with high QPS</a></li><li class="sidebar-sub-header"><a href="/views/other/topk/topk.html#_2-5-approximate-top-k" class="sidebar-link">2.5 Approximate Top K</a></li><li class="sidebar-sub-header"><a href="/views/other/topk/topk.html#_2-5-1-count-min-sketch" class="sidebar-link">2.5.1 Count-Min Sketch</a></li><li class="sidebar-sub-header"><a href="/views/other/topk/topk.html#_2-5-2-losssy-counting" class="sidebar-link">2.5.2 Losssy Counting</a></li></ul></li><li><a href="/views/other/topk/topk.html#_3-总结" class="sidebar-link">3. 总结</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/views/other/topk/topk.html#references" class="sidebar-link">References</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-19557b78><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>浅谈Top K问题</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>Shopee Supply Chain</span>
            
          <!---->
          2021
        </a></span></div></div> <div data-v-19557b78><main class="page"><div class="page-title" style="display:none;"><h1>浅谈Top K问题</h1> <hr> <div data-v-484a899e><i class="iconfont reco-account" data-v-484a899e><span data-v-484a899e>Jiaqiang Li</span></i> <i class="iconfont reco-date" data-v-484a899e><span data-v-484a899e>2020-12-18</span></i> <!----> <i class="iconfont reco-tag tags" data-v-484a899e><span class="tag-item" data-v-484a899e>
      Algorithm
    </span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><h2 id="_1-背景"><a href="#_1-背景" class="header-anchor">#</a> 1. 背景</h2> <p>前不久我在周会上分享了<a href="https://drive.google.com/file/d/1fftN6yrv_4kyLeLBclI6XZtc9y8NRWx1/view" target="_blank" rel="noopener noreferrer">浅谈海量数据<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，主要简单介绍了<strong>MapReduce</strong>的原理及其应用(<strong>Page Rank</strong>)。而这篇文章是基于上次的分享，再来浅谈周会分享中提到的<strong>Top K问题</strong>(也有一个类似的问题叫<strong>The Heavy Hitters Problem</strong>，主要是寻找出现频数较高的数值)。Top K问题在我们的日常生活中也是处处可见，如购物平台的推荐商品，搜索热词，检测较大流量的TCP连接(检测DDoS)等等。本文主要通过<strong>Top K</strong>问题来阐述<strong>MapReduce</strong>在大数据处理中的应用，详细描述了在单台机器上，多台机器上，低的QPS，高的QPS中MapReduce如何工作，最后简单介绍了近似算法来解决Top K问题。</p> <h2 id="_2-阐述top-k问题"><a href="#_2-阐述top-k问题" class="header-anchor">#</a> 2. 阐述Top K问题</h2> <p>我们先来看看一个简化了的Top K问题：输入是一个长度为<strong>n</strong>的数组<strong>A</strong>以及一个参数<strong>k</strong>，<strong>n</strong>是一个非常大的数，如几百万，几千万，而<strong>k</strong>是一个相对较小的数，如10，100或1000。目标就是找到在数组<strong>A</strong>里出现频数至少是<strong>n/k</strong>的数值。</p> <p>在阐述如何解决Top K问题之前，先让我们来看一个读书时老师会问到的问题(题目来源于LeetCode)：</p> <p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener noreferrer">(Top K Frequent Elements) Given a non-empty array of integers, return the k most frequent elements.<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>接下来我会以这个问题为例进行Top K问题的介绍。</p> <h3 id="_2-1-top-k-on-single-node"><a href="#_2-1-top-k-on-single-node" class="header-anchor">#</a> 2.1 Top K on Single Node</h3> <p>在<strong>单结点</strong>(一台机器)上解决Top K问题（或者在单台机器上解决问题），通常用到的数据结构是<strong>HashMap</strong>和<strong>Heap</strong>(小顶堆), 时间复杂度是<strong>O(n + n * lgk) = O(n * lgk)</strong>, 空间复杂度是**O(|n| + k), |n| **是不重复数值的个数。</p> <ul><li><strong>HashMap</strong>主要是记录每个元素出现的频数</li> <li>把HashMap中记录的数值放进小顶堆(大小为K)，当堆还没满时，直接把数值放进去就行</li> <li>当堆满时，比较堆顶的数值和准备放进堆的数值，如果准备放进堆的数值的频数比堆顶数值频数大，把堆顶数值踢掉，放进新的数值，反之不做任何操作。</li> <li>最后堆里就存储了Top K的数值(出现频数的Top K数值)。</li> <li>以下以python为例简单写下此过程，而关于堆的实现，可以参考<a href="https://algs4.cs.princeton.edu/home/" target="_blank" rel="noopener noreferrer">Algorithms, 4th Edition<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> (非常棒的介绍算法的书籍) 。</li></ul> <div class="language-python line-numbers-mode"><pre class="language-python"><code><span class="token keyword">from</span> Queue <span class="token keyword">import</span> PriorityQueue

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">&quot;&quot;&quot;
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        &quot;&quot;&quot;</span>
        m <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>
            m<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">.</span>get<span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
        
        q <span class="token operator">=</span> PriorityQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> num <span class="token keyword">in</span> m<span class="token punctuation">:</span>
            q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token punctuation">[</span>m<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">,</span> num<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> q<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> k<span class="token punctuation">:</span>
                q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
        
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> q<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
            ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span> ans
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="_2-2-top-k-on-multiple-node"><a href="#_2-2-top-k-on-multiple-node" class="header-anchor">#</a> 2.2 Top K on Multiple Node</h3> <p>但是当数据量非常大的时候，单机处理Top K是否恰当。比如有<strong>一组100T的文件，文件内容是10亿</strong>用户当天的搜索记录，求当天搜索的热搜词。如果继续用单机处理这个问题，主要会出现两个问题：文件太大内存不够，处理速度非常慢。这时候，我们可以考虑用多台机器进行<strong>MapReduce</strong>处理，关于MapReduce可以参考之前的分享<a href="https://drive.google.com/file/d/1fftN6yrv_4kyLeLBclI6XZtc9y8NRWx1/view?usp=sharing" target="_blank" rel="noopener noreferrer">浅谈海量数据<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <ul><li>可以每次从100T的文件中每次读取1G的文件，进行搜索词拆分并进行哈希处理，发送到相对应的机器进行Top K处理。</li> <li>把各个机器的Top K搜索词进行合并，并取其中的Top K搜索词。( <strong>list of Top K {top k1, top k2, ...} =&gt; merge to get final top k</strong> )</li></ul> <p><img src="/assets/img/2.1_MapReduce_Process.c6fc829a.png" alt="">
图2.1 MapReduce 流程</p> <h3 id="_2-3-realtime-top-k-with-low-qps"><a href="#_2-3-realtime-top-k-with-low-qps" class="header-anchor">#</a> 2.3 Realtime Top K with low QPS</h3> <p>之前讨论的Top K问题都是对于<strong>静态数据</strong>来说的。现在又有另外一个场景，有<strong>实时数据</strong>的流入，我们应该如何解决Top K问题呢？</p> <p>想法一：</p> <ul><li>当有新数据流入时，把数据写入磁盘中</li> <li>当有请求Top K时，基于磁盘上的数据求解Top K</li> <li></li></ul> <p>这样做主要有两个问题：</p> <ul><li>重复计算，每次都要基于磁盘中的数据重新进行Top K求解</li> <li>计算速度太慢了</li></ul> <p>想法二：</p> <ul><li>当有新数据流入时，把数据存储在HashMap</li> <li>当HashMap更新了，相对应更新Priority Queue</li> <li>从Priority Queue得到Top K</li></ul> <p>这样做主要有两个问题：</p> <ul><li>OOM (内存不够)</li> <li>当机器挂掉时候会丢失当前的数据</li></ul> <p>那么为什么会导致内存不够呢？<strong>HashMap</strong> ? 还是<strong>Priority Queue</strong> ?</p> <p>我觉得是HashMap会导致内存不够，因为Priority Queue只是会保存K个key-value数值对，而<strong>HashMap则是不断地新增数值，最终导致内存不够用</strong>。</p> <p>现在，我们可以尝试用<strong>数据库(如MySQL)去替代HashMap</strong>，这样我们可以把单词的频数存储在数据库中，如下：</p> <table><thead><tr><th>id</th> <th style="text-align:center;">word</th> <th style="text-align:right;">count</th></tr></thead> <tbody><tr><td>1</td> <td style="text-align:center;">computer</td> <td style="text-align:right;">10</td></tr> <tr><td>2</td> <td style="text-align:center;">science</td> <td style="text-align:right;">9</td></tr></tbody></table> <p>这时候如果还用Priority Queue去保存Top K的值就会出现问题。如果用数据库替代HashMap，新的单词可以跟以前一样，直接和小顶堆的根值比较即可；但<strong>如果这个单词已经存在于小顶堆里面，我们需要更新该单词在小顶堆中的值，而不是让该单词直接和小顶堆的根值进行比较</strong>。</p> <p>这时候，我们可以考虑用TreeMap去代替<strong>Priority Queue</strong>。<strong>TreeMap</strong>是有序的key-value集合，通过红黑树来实现，支持查找和删除操作，可以在O(logn)时间内做查找，插入和删除等操作。这样对于已经存在于TreeMap的单词，我们可以更新该单词对应的频数值。</p> <h3 id="_2-4-realtime-top-k-with-high-qps"><a href="#_2-4-realtime-top-k-with-high-qps" class="header-anchor">#</a> 2.4 Realtime Top K with high QPS</h3> <p>但是当数据流有<strong>很高的QPS</strong>，这时候我们应该如何去解决这个问题呢？QPS很高，意味着数据库不能实时地做出反应，因为读写的频率太高了，这导致了<strong>很高的延迟性(high latency)</strong>。</p> <p>这时候我们可以考虑2.2提到的多节点处理Top K的方法去解决这个问题。但是当某个单词非常热门，这会导致某个节点的 写QPS 会非常高，同样又会导致**2.2很高的延迟性(high latency)**2.2。流程如下：</p> <p><img src="/assets/img/2.2_MapReduce_Process.b73d1ecb.png" alt="">
图2.2 获取Top K流程</p> <ul><li>新的数据发送给Slave 1进行处理</li> <li>Slave 1会把新的数据存储在数据库上</li> <li>数据库的更新会触发TreeMap的更新，此时TreeMap会先进入block状态，然后对新数据进行更新</li> <li>此时Master接收到Top K的请求</li> <li>Master Node会去请求Slave 1，返回Top K</li> <li>Slave 1就会去TreeMap请求Top K</li> <li>因为数据流<strong>有非常高的QPS</strong>，数据库不停的进行读写操作，相对应TreeMap不停地进行<strong>Block和Update操作</strong>，此时TreeMap还<strong>处于Block</strong>状态，于是返回Wait消息给Slave 1</li> <li>Slave 1返回Wait的消息给Mater Node，此时Master Node并不能实时得到Top K的数据，<strong>导致很高的延迟性</strong></li></ul> <p>就像是算法里面的时间复杂度和空间复杂度，通过<strong>增加空间复杂度来降低时间复杂度</strong>，比如用并查集解决朋友圈问题。对于上面阐述的高延迟性问题，同样可以<strong>牺牲一点精确性来减少</strong>延迟性。这时候我们可以利用<strong>缓存</strong>来解决高延迟性的问题。流程如下：</p> <p><img src="/assets/img/2.3_MapReduce_Process_Cache.25017346.png" alt="">
图2.3 获取Top K流程(cache)</p> <ul><li>新的数据发送给Slave 1进行处理</li> <li>Slave 1会把新的数据缓存起来</li> <li>每隔一段时间，如每隔10秒缓存会把缓存的数据存储在数据库上</li> <li>数据库的更新会触发TreeMap的更新，此时TreeMap会先进入block状态，然后对新数据进行更新</li> <li>此时Master接收到Top K的请求</li> <li>Master Node会去请求Slave 1，返回Top K</li> <li>Slave 1就会去TreeMap请求Top K</li> <li>此时因为数据的更新并不是特别频繁，TreeMap并没有一直处于block状态，此时TreeMap返回Top K数值</li> <li>Slave 1返回Top K数值给Mater Node</li></ul> <h3 id="_2-5-approximate-top-k"><a href="#_2-5-approximate-top-k" class="header-anchor">#</a> 2.5 Approximate Top K</h3> <p>现在有一个问题，对于高频词问题，肯定会有很多单词出现的频率非常低，这样<strong>低频词会占据磁盘很大部分的容量</strong>。就像2.4提到的用缓存解决高QPS的Top K问题，适当<strong>降低精确性来提高空间的使用率</strong>。接下来我们来看看<strong>Count-Min Sketch</strong>和<strong>Lossy Counting</strong>如何解决<strong>Top K</strong>问题，这两个近似算法都是优化了存储单词出现频数的方法 [1][2]，计算Top K那部分依旧是用小顶堆或Tree Map来解决。</p> <h3 id="_2-5-1-count-min-sketch"><a href="#_2-5-1-count-min-sketch" class="header-anchor">#</a> 2.5.1 Count-Min Sketch</h3> <p><strong>Count-Min Sketch</strong>类似于<strong>Bloom Filter</strong>，都是用多个哈希函数去解决冲突问题 [1][2][3]。假设我们有<strong>d个哈希函数</strong>，一个数组T(d行，m列)，对于数据流中的每个数据，用d个哈希函数计算得到<strong>d个哈希值</strong>，把其d个哈希值对<strong>m进行取模运算</strong>，并对其所在数组的位置的值<strong>加一</strong>，即T[hash_func][hash_value] + 1。当我们去搜索某个单词的频数时，通过d个哈希函数我们可以得到<strong>d个哈希值</strong>，相对应可以找到d个哈希值对应其所在的数组的值，这时我们<strong>选择数值最小的数值</strong>作为该单词的<strong>频数</strong> [4]。</p> <p><img src="/assets/img/2.4_CountMinSketch.5cf6742c.png" alt="">
图2.4 Count-Min Sketch [4]</p> <p><strong>Count-Min Sketch</strong>的优点就是可以<strong>节省很多空间</strong>；缺点是对于低频词，有可能通过计算把该单词变成高频词。</p> <h3 id="_2-5-2-losssy-counting"><a href="#_2-5-2-losssy-counting" class="header-anchor">#</a> 2.5.2 Losssy Counting</h3> <p><strong>Lossy Counting</strong>是另一个用来解决数据流中的Top K问题的近似算法，对于数据流中的数据，如果<strong>其出现频数超过某个自定义的数值</strong>，就把该数值记录下来 [3]。首先我们先创建一个HashMap，用来存储单词的频数(key是单词，value是其频数)，然后建立<strong>data frame(如数组)</strong>，如下：</p> <p><img src="/assets/img/2.5_DataFrame.612334ec.png" alt="">
图2.5 Data Frame [3]</p> <p>从数据流中读取数值，并把数据放进<strong>data frame</strong>中，统计其<strong>频数f</strong>，并将<strong>其频数减一</strong>(我觉得这是非常非常非常聪明的一种做法)，如下：</p> <p><img src="/assets/img/2.6_DataFrame.96f3f2bf.png" alt="">
图2.6 计算Data Frame中数值的频数 [3]</p> <p>把计算得到的频数放进<strong>HashMap</strong>中，并把HashMap中<strong>频数为0</strong>的key-value数值对<strong>删除</strong>(这就是为什么计算频数时需要将其减一的原因)。重复以上步骤，以此来统计单词出现的频数，如下：</p> <p><img src="/assets/img/2.7_DataFrame.38425179.png" alt="">
图2.7 计算Data Frame中数值的频数 [3]</p> <p>这个方法背后的思想主要是即使在<strong>每个data frame</strong>中计算频数时都要减一，但是高频词出现的频率就很高，这就说明<strong>在每一个data frame中高频词在HashMap中被删除的几率会很低</strong>。当我们不断从数据流中读取数据，<strong>低频词在HashMap中记录的频数会越来越低，直至到零时就会从HashMap中删除掉[3][5]</strong>。</p> <h2 id="_3-总结"><a href="#_3-总结" class="header-anchor">#</a> 3. 总结</h2> <p><strong>Top K</strong>问题在我们的日常生活中是处处可见，如购物平台的推荐商品，搜索热词，检测较大流量的TCP连接(检测DDoS)等等。在单台机器上，解决<strong>Top K</strong>问题，通常需要堆的帮助选择出现频数最高的K个数值。但是当数据越来越大的时候，单台机器通常内存不足以处理如此庞大的数据，这时候就需要用到多台机器对数据进行<strong>Map和Reduce合并处理</strong>。但是实际生活中，数据是流动的，不断增加的，当机器的<strong>QPS比较低</strong>的时候，这时候可以用<strong>数据库存</strong>储记录每个数值出现的频数，每当有新的数据时，更新数据库，并把此数值的频数和小顶堆的根值比较即可，这时候，我们可以考虑用<strong>TreeMap</strong>去代替Priority Queue，因为<strong>TreeMap是有序的key-value集合</strong>，通过红黑树来实现，支持查找和删除操作，可以在O(logn)时间内做查找，插入和删除等操作。当机器的QPS比较高的时候，因为读写频率比较高，此时如果不停的访问数据库，很容易造成很高的延迟性，这时候可以<strong>缓存</strong>一部分数据来解决高延迟性的问题。此外，如果可以接受结果会有一些偏差，我们也可以使用一些<strong>近似算法来解决数据流的Top K问题</strong>，如Count-Min Sketch和Losssy Counting。</p> <h2 id="references"><a href="#references" class="header-anchor">#</a> References</h2> <p><strong>[1]</strong> T. Roughgarden, G. Valiant (Mar. 30, 2016). Stanford University CS168: The Modern Algorithmic Toolbox Lecture #2: Approximate Heavy Hitters and the Count-Min Sketch. Retrieved from http://theory.stanford.edu/~tim/s17/l/l2.pdf.</p> <p><strong>[2]</strong> Vazirani, Rao. University of California, Berkeley, CS270: Lecture 15 Streaming Algorithms: Frequent Items. Retrieved from https://people.eecs.berkeley.edu/~satishr/cs270/sp11/rough-notes/Streaming-two.pdf.</p> <p><strong>[3]</strong> M. Vogiatzis (July 18, 2015). Frequency Counting Algorithms over Data Streams. Retrieved from https://micvog.com/2015/07/18/frequency-counting-algorithms-over-data-streams/.</p> <p><strong>[4]</strong> Z. Jiang (Nov. 13, 2017), Top K Frequent Items Algorithms. Retrieved from https://zpjiang.me/2017/11/13/top-k-elementes-system-design/.</p> <p><strong>[5]</strong> M. Hadjieleftheriou, S. Muthukrishnan, R. Berinde, P. Indyk, M. Strauss. Finding Frequent Items in Data Streams. Retrieved from http://archive.dimacs.rutgers.edu/Workshops/WGUnifyingTheory/Slides/cormode.pdf.</p></div> <footer class="page-edit" style="display:none;"><!----> <!----></footer> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-44bd5a18 data-v-44bd5a18><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-44bd5a18><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-44bd5a18></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-44bd5a18></path></svg></div></div></div>
    <script src="/assets/js/app.89d7a7af.js" defer></script><script src="/assets/js/3.39c0dfdf.js" defer></script><script src="/assets/js/1.fc4f2573.js" defer></script><script src="/assets/js/11.42709e7b.js" defer></script>
  </body>
</html>
